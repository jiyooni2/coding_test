
복잡도
    시간복잡도
        Big-O
        소스코드가 내부적으로 다른 함수를 호출한다면 내부 함수의 시간복잡도까지 고려
        빅오 표기법이 항상 절대적이진 않음, 큰 상수값을 가지고 있을 수도 있음
        일반적으로 코딩테스트에서 O(N^3)을 넘어가면 문제풀이에서 사용하기 아려움
        
        1 -> log N -> N -> NlogN -> N^2 -> N^3 -> 2^N
        대략 데이터의 갯수(N)이 1000만개를 넘어가며 시간 제한이 1초라면, O(N) 알고리즘을 작성해야 함을 예측
        
        NlogN : N이 1000일때 연산횟수 10000 (log 1000 := 10)
        
        C언어 기준, 연산횟수 10억을 넘어가면 1초 이상 시간 소요


    공간복잡도
        대부분 배열을 사용해서 풀어야 한다
        리스트의 크기가 일반적으로 1000만단위가 넘어가지 않도록 해야 함

    성능을 실제로 확인하기 위해서, 시간 측정 라이브러리를 사용해보는 것도 좋음
    코딩테스트를 풀 때는, 가독성을 해치지 않는 선에서 최대한 복잡도를 낮게 작성해야 함
    서로 다른 알고리즘을 비교하여 특정 상황에 무엇이 더 좋을지 설명할 수 있어야 함

시간측정 라이브러리(js)
    1. console.time
    2. performance.now
        const startDate = performance.now();
        const endDate = performance.now();
        console.log(endDate-startDate);

Greedy
    현재 상황에서 지금 당장 좋은것만 고르는 방법
    매 순간 가장 좋아보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않음
    정렬 알고리즘과 짝을 이뤄 자주 출제

    탐욕법이 최적의 해를 찾을 수 없는 가능성이 높음
    탐욕적으로 문제에 접근했을 때 정확한 답을 찾을 수 있다는 보장이 있을 때 매우 효과적이고 직관적
    
Implementation
    머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
    완전 탐색
        모든 경우의 수를 다 계산하는 방법
    시뮬레이션
        문제에서 제시한 알고리즘을 한 단계씩 차례로 직접 수행
    
    실수형 변수는 유효숫자에 따라서 연산 결과가 원하는 값이 나오지 않을 수 있다는 점을 기억
    자신의 코드가 1초에 2000만번의 연산을 수행한다고 가정하고 문제를 풀면 실행시간 제한에 안정적(파이썬 기준)
    (파이썬 사용시 PyPy3 지원한다면 PyPy3 이용)

DFS/BFS
    탐색
        많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
    자료구조
        데이터를 표현하고 관리하고 처리하기 위한 구조
        오버플로우와 언더플로우를 고려하자
    스택
        array.push/pop 또는 shift/unshift로 구현
    큐  
        앞쪽은 shift/unshift 뒤쪽은 push/pop으로 deque 구현
    재귀함수
        자기 자신을 다시 호출하는 함수
        반드시 종료조건(베이스)을 명시해야하며, 문제가 점점 작아지는 방향으로 이루어져야 함
        컴퓨터 내부에서 재귀함수의 수행은 스택 자료구조를 이용
    
DFS(Depth-First Search, 깊이 우선 탐색)
    그래프에서 깊은 부분을 우선적으로 탐색
    인접 행렬(Adjacency Matrix) / 인접 리스트(Adjacency List)
    인접 리스트를 구현할 때도 단순히 2차원 리스트를 이용하면 됨
    [[1,2],[0],[0]] => 0번 노드가 1/2와 연결 1번 노드가 0과 연결 2번 노드가 0과 연결 
    
    인접행렬
        모든 관계를 저장, 노드가 많을수록 메모리가 불필요하게 낭비(sparse Matrix니까 당연)
        탐색시 O(1)
    
    인접리스트
        연결된 정보만을 저장하기 때문에 메모리를 효율적 사용
        정보를 얻는 속도가 느림, 연결된 데이터를 하나식 확인해야 함
    
    알고리즘
        1. 탐색 시작 노드를 스택에 삽입하고 방문 처리하기
        2-1. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문처리
        2-2. 방문하지 않은 인접노드가 없으면 스택에서 최상단 노드를 꺼냄
        3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.


복잡도
    시간복잡도
        Big-O
        소스코드가 내부적으로 다른 함수를 호출한다면 내부 함수의 시간복잡도까지 고려
        빅오 표기법이 항상 절대적이진 않음, 큰 상수값을 가지고 있을 수도 있음
        일반적으로 코딩테스트에서 O(N^3)을 넘어가면 문제풀이에서 사용하기 아려움
        
        1 -> log N -> N -> NlogN -> N^2 -> N^3 -> 2^N
        대략 데이터의 갯수(N)이 1000만개를 넘어가며 시간 제한이 1초라면, O(N) 알고리즘을 작성해야 함을 예측
        
        NlogN : N이 1000일때 연산횟수 10000 (log 1000 := 10)
        
        C언어 기준, 연산횟수 10억을 넘어가면 1초 이상 시간 소요


    공간복잡도
        대부분 배열을 사용해서 풀어야 한다
        리스트의 크기가 일반적으로 1000만단위가 넘어가지 않도록 해야 함

    성능을 실제로 확인하기 위해서, 시간 측정 라이브러리를 사용해보는 것도 좋음
    코딩테스트를 풀 때는, 가독성을 해치지 않는 선에서 최대한 복잡도를 낮게 작성해야 함
    서로 다른 알고리즘을 비교하여 특정 상황에 무엇이 더 좋을지 설명할 수 있어야 함

시간측정 라이브러리(js)
    1. console.time
    2. performance.now
        const startDate = performance.now();
        const endDate = performance.now();
        console.log(endDate-startDate);

Greedy
    현재 상황에서 지금 당장 좋은것만 고르는 방법
    매 순간 가장 좋아보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않음
    정렬 알고리즘과 짝을 이뤄 자주 출제

    탐욕법이 최적의 해를 찾을 수 없는 가능성이 높음
    탐욕적으로 문제에 접근했을 때 정확한 답을 찾을 수 있다는 보장이 있을 때 매우 효과적이고 직관적
    
Implementation
    머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
    완전 탐색
        모든 경우의 수를 다 계산하는 방법
    시뮬레이션
        문제에서 제시한 알고리즘을 한 단계씩 차례로 직접 수행
    
    실수형 변수는 유효숫자에 따라서 연산 결과가 원하는 값이 나오지 않을 수 있다는 점을 기억
    자신의 코드가 1초에 2000만번의 연산을 수행한다고 가정하고 문제를 풀면 실행시간 제한에 안정적(파이썬 기준)
    (파이썬 사용시 PyPy3 지원한다면 PyPy3 이용)

복잡도
    시간복잡도
        Big-O
        소스코드가 내부적으로 다른 함수를 호출한다면 내부 함수의 시간복잡도까지 고려
        빅오 표기법이 항상 절대적이진 않음, 큰 상수값을 가지고 있을 수도 있음
        일반적으로 코딩테스트에서 O(N^3)을 넘어가면 문제풀이에서 사용하기 아려움
        
        1 -> log N -> N -> NlogN -> N^2 -> N^3 -> 2^N
        대략 데이터의 갯수(N)이 1000만개를 넘어가며 시간 제한이 1초라면, O(N) 알고리즘을 작성해야 함을 예측
        
        NlogN : N이 1000일때 연산횟수 10000 (log 1000 := 10)
        
        C언어 기준, 연산횟수 10억을 넘어가면 1초 이상 시간 소요


    공간복잡도
        대부분 배열을 사용해서 풀어야 한다
        리스트의 크기가 일반적으로 1000만단위가 넘어가지 않도록 해야 함

    성능을 실제로 확인하기 위해서, 시간 측정 라이브러리를 사용해보는 것도 좋음
    코딩테스트를 풀 때는, 가독성을 해치지 않는 선에서 최대한 복잡도를 낮게 작성해야 함
    서로 다른 알고리즘을 비교하여 특정 상황에 무엇이 더 좋을지 설명할 수 있어야 함

시간측정 라이브러리(js)
    1. console.time
    2. performance.now
        const startDate = performance.now();
        const endDate = performance.now();
        console.log(endDate-startDate);

Greedy
    현재 상황에서 지금 당장 좋은것만 고르는 방법
    매 순간 가장 좋아보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않음
    정렬 알고리즘과 짝을 이뤄 자주 출제

    탐욕법이 최적의 해를 찾을 수 없는 가능성이 높음
    탐욕적으로 문제에 접근했을 때 정확한 답을 찾을 수 있다는 보장이 있을 때 매우 효과적이고 직관적
    
